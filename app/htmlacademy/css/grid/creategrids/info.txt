Попробуем поймать поток документа и разобраться что это такое. Взглянем на тонкости свойства float и блочно-строчных элементов.
Отработаем основные приёмы построения сеток.
-----------------------------------------------
Пробуем управлять потоком

О понятии потока документа рассказывается в курсе про позиционирование.

Поток — это порядок отображения элементов на странице. По умолчанию блочные элементы отображаются как прямоугольные области,
идущие друг за другом сверху вниз, а строчные элементы располагаются сверху вниз и слева направо и при необходимости переносятся на
новую строку.
Потоком можно управлять и изменять привычное поведение элементов в потоке. Например, можно заставить блочные элементы двигаться не
 сверху вниз, а выстраиваться в несколько колонок.
А научившись управлять потоком, вы сможете строить сетки.
В первой серии заданий мы продемонстрируем как один и тот же HTML-код можно выстроить в разные потоки. Например, вот так:

flowcontrol
----------------
Управление потоком, шаг 2

На первом шаге мы с помощью свойства float изменили поведение первого блока.

Обратите внимание, как он стал наезжать на последующие блоки. Это одна из особенностей флоатов, которую мы разберём позже в курсе.

А пока продолжим: сейчас будем изменять поведение второго блока.

flowcontrol
-------------------
Управление потоком, шаг 3

Со вторым блоком разобрались. Теперь уже первые два блока наезжают на третий.

Чтобы получить нужный нам поток, осталось задать размеры третьему блоку, отцентровать его и избавиться от эффекта «наезжания».

Поможет нам в этом свойство clear.

flowcontrol
-----------------------------
Создадим другой поток
У вас получилось создать первый поток. Теперь попробуем те же самые элементы выстроить по-другому. Вот так:

flowcontrolse
------------------------------
Другой поток, шаг 2

А пока вы пошагово создаёте второй поток, поговорим о сетках.

Сетка — это взаимное расположение крупных блоков сайта. Вспомните любой сайт, например, ВКонтакте или HTML Academy.

У ВКонтакте простая сетка, которая состоит из верхней части, или «хедера», под которой располагаются две колонки, а в самом
низу расположен «футер» или нижняя часть сайта. Вот так схематично можно представить сетку ВКонтакте:

-------------------------------------
 хедер
-------------------------------------
 левая колонка | правая колонка
 меню          | основное содержание
-------------------------------------
 футер
-------------------------------------
У HTML Academy на разных страницах используются разные сетки. Например, на главной странице есть двухколончатый
хедер, под ним содержание страницы в три колонки, затем нижнее меню и двухколончатый футер.

Как вы понимаете, сетки могут быть самыми разными.
flowcontrolse
------------------------------------
Другой поток, шаг 3

Что нужно знать и уметь, чтобы строить сетки? Две вещи:

управлять размерами элементов;
управлять поведением элементов в потоке.
Первая часть детально разбирается в курсе «Блочная модель документа». Там вы учитесь:

задавать размеры;
рамки;
внешние и внутренние отступы;
рассчитывать полный размер элемента;
рассчитывать занимаемую им площадь.
Управлять поведением в потоке мы будем учиться в этом курсе.

Существует несколько способов управлять потоком и строить сетки:

флоаты;
инлайн-блоки;
табличная вёрстка;
флексбоксы.
Табличная вёрстка — самый простой для понимания способ построения сеток.
Но он считается устаревшим и использовать его не рекомендуется. В будущем можно будет использовать для такой вёрстки не таблицы,
 а элементы с display: table, display: table-row и display: table-cell.
Флексбоксы — это новая и очень мощная технология для построения сеток. К сожалению, её поддержка браузерами ещё достаточно слабая.
А флоаты и инлайн-блоки мы разберём в этом курсе более подробно. Основной упор сделаем на флоаты, т. к.
 сейчас это самый распространённый способ построения сеток.
А пока что завершите создание своей второй сетки.

flowcontrolse
-----------------------------------
Погружение в флоаты

А теперь детально разберём свойство float, его значения, особенности поведения и способы применения.

Т. к. у этого свойства нет устоявшегося русского перевода или термина, то мы будем называть его «флоатом», а также
использовать конструкции наподобие «зафлоатить».
Изначально float было предназначено для того, чтобы включать обтекание элементов текстом. Наподобие того, как в более
старой версии HTML текст обтекал изображения c атрибутами align="left" или align="right".

То есть, можно сказать, что float — это свойство, включающее режим обтекания. Но, как часто бывает, судьба уготовила
ему совсем другую роль.

Свойство float имеет следующие значения:

left — прижимает элемент к левому краю родителя, другие элементы обтекают его справа;
right — прижимает элемент к правому краю родителя, другие элементы обтекают его слева;
none — отключает режим обтекания и возвращает элементу нормальное поведение.
Обратите внимание, что зафлоатить элемент по центру нельзя.

Иллюстрация в задании взята из статьи «Раскладка в CSS: float».

deepfloat
-----------------------------------
float и ширина

Вы уже знаете, что по умолчанию блочные элементы растягиваются на всю доступную ширину родителя.
Если мы задаём элементу свойство float:left или float:right, то он прижимается к левому или правому краю,
а также начинает ужиматься по ширине под своё содержимое. С той стороны, которая не прижата к краю родителя, появляется свободное место.
Это место может быть занято другими элементами.
Зафлоаченному элементу можно явно задавать размеры и отступы.
Есть тонкость, связанная со строчными элементами. Если зафлоатить строчный элемент, то он начинает вести себя
как блочный, а именно: воспринимать размеры и отступы.

floatwidth
--------------------------------------
float и выпадание из потока

Про выпадание элементов из потока при абсолютном и фиксированном позиционировании мы поговорим в курсе «Позиционирование».
 А сейчас рассмотрим выпадание при флоатах.

Зафлоаченные элементы выпадают из потока, но лишь частично:

Блочные элементы, которые идут в коде после зафлоаченного блока, перестают его замечать. Они подтягиваются вверх и занимают
 его место, как будто его и нет.
Строчные же элементы, расположенные в коде после зафлоаченного блока, начинают обтекать его со свободной стороны.
Ещё раз: для блочных элементов флоатные не существуют, но текст внутри блоков флоатные обтекает.

Такое поведение флоатов даёт интересные эффекты:

Эффект прохождения сквозь блоки. Проявляется, когда зафлоаченный элемент выше, чем несколько последующих за ним блоков.
Эффект выпадания из родителя или схлопывания родителя. Проявляется тогда, когда все дочерние блоки в родителе зафлоачены.
В этом случае родитель схлопывается по высоте, как будто в нём нет содержимого, а блоки выпадают из него.


floatleavestream
---------------------------------------
Флоат рядом с флоатом

Флоатные элементы становятся невидимыми для блочных элементов и видимыми для текста. А как же они взаимодействуют друг с другом?
Если вкратце то: флоатные элементы видят друг друга.
Идущие друг за другом флоаты выстраиваются в ряд, пока им хватает свободного места. Если места не хватает,
то они начинают переноситься на следующую строчку. Почти как текст.
Как раз эта особенность флоатов и позволила применять их для создания сеток. Ведь в начале двухтысячных в CSS не
было никакого другого способа создавать колонки и задавать им размеры.
Блочные элементы всегда располагались в разных строках. А строчные элементы, хоть и могли располагаться на одной строке,
 совершенно не воспринимали размеры. Позиционирование тоже не подходило для сеток, т. к. элементы выпадали из потока.
В общем, флоаты оказались как нельзя кстати для тех, кто решил уходить с табличной вёрстки.

floatandfloat
---------------------------------------
Когда флоатов много, а места мало

Следует отметить, что поведение нескольких флоатов, когда им не хватает места в одной строке, является очень странным.
Когда не влезающий флоат переносится на новую строку, возможно несколько вариантов и не все из них логичны. Например,
 флоат может «зацепиться» за один из предшествующих флоатов и встать ниже не в самом начале строки, а за предшествующим.
В этом упражнении примеры специально подобраны так, чтобы вы увидели странности поведения флоатов при недостатке места.
Естественно, эти особенности повлияли на приёмы использования флоатов в создании раскладок (еще одно название для сеток).
 Но об этом позже.

floatnospace
---------------------------------------
Испытание: пазл на флоатах

В качестве первого испытания мы подготовили небольшую головоломку. Суть её такова:

Все стили готовы к использованию, а редактор CSS заблокирован.
Но вы можете изменять HTML.
Задача заключается в том, чтобы правильно подобрать порядок блоков.
Конечно, головоломка сделана таким образом, чтобы вы прочувствовали все тонкости поведения флоатов.
Обратите внимание, что среди блоков есть не зафлоаченный блок. И это не ошибка.

Напомним об одной тонкости: для того, чтобы флоатный блок мог обтекаться обычным, он должен в коде располагаться выше обычного.

floatpazzle
---------------------------------------
Свойство clear

Свойство clear запрещает обтекание элемента другими элементами. Вот его значения:
left — запрещено обтекание слева;
right — запрещено обтекание справа;
both — запрещено обтекание с обеих сторон;
none — обтекание разрешено.

Если после флоатного элемента расположен элемент с запрещённым обтеканием, то последний опускается под флоатный.
Свойство clear учит блочные элементы «видеть» зафлоаченные.

floatclear
---------------------------------------
Борьба с выпаданием флоатов: распорки

Эффект выпадания флоатов из родителя был большой проблемой при построении сеток. Ведь сетки на флоатах обычно делаются вот так:

Создаём блок-контейнер для колонок.
В контейнер добавляем флоатные блоки-колонки.
Рассчитываем ширины колонок так, чтобы им хватало места в родителе.
Такой подход работает неплохо. Но проблемы начинаются тогда, когда у контейнера есть фон, отличный от фона страницы.
 Когда колонки выпадали, родитель схлопывался и фон пропадал.

Необходимо было найти способ борьбы с выпаданием. Тут и пригодилось свойство clear:both. Стали применять такую структуру:

<div class="container"> - блок-контейнер
    <div class="column1">...</div> - колонка, флоат
    <div class="column2">...</div> - колонка, флоат
    <div class="clearfix"></div> - распорка с clear:both
</div>
Т. е. начали добавлять после зафлоаченных колонок пустой элемент-распорку со свойством clear:both. Этот элемент видел колонки
, не давал им пройти через себя, а заодно и растягивал родительский блок по высоте.

Для таких распорок прижилось специальное название класса — clearfix.

floatspacers
---------------------------------------
Борьба с выпаданием флоатов: псевдораспорки

Хорошие верстальщики не очень любят, когда в вёрстке появляются ненужные дополнительные элементы и стараются от них избавляться.
До поры до времени с блоками-распорками приходилось мириться, т. к. без них было никак не обойтись. Но время шло и в браузерах
появилась поддержка так называемых псевдоэлементов.
Псевдоэлементы позволяют с помощью CSS вставить в структуру HTML-документа узлы, которых нет в HTML коде. Т. е. можно вставить
в код элемент и не писать его в HTML. Благодаря псевдоэлементам появилось решение проблемы флоатов без использования дополнительного элемента.

Назовём это решение псевдораспорками. Есть несколько его вариаций, но вот одна из распространённых. В CSS добавляется следующее правило:

.clearfix::after {
    content: "";
    display: table;
    clear: both;
}
А затем класс clearfix добавляется к контейнеру, внутри которого лежат флоатные колонки. После этого в контейнер не нужно добавлять
 дополнительный элемент-распорку, т. к. распорка создаётся с помощью псевдоэлемента.

Подробнее псевдоэлементы мы разберем в одном из последующих курсов.

no need of clear fix div.

pseudospacers
----------------------------------------
Простейшая сетка, шаг 1

Мы разобрали по косточкам свойство float, познакомились с clear и научились бороться с некоторыми проблемами флоатов.
В этой части курса мы будем практиковаться строить сетки на флоатах.
И начнём с простейшей сетки «хедер - две колонки - футер». Одна колонка будет фиксированной ширины, а вторая будет
 растягиваться в зависимости от ширины контейнера.
В исходном состоянии у нас 4 блока, расположенных друг под другом. Первым делом займёмся боковой панелью или «сайдбаром»:
зафлоатим её влево и зададим её фиксированную ширину.

Простейшая сетка, шаг 2 [18/32]

Мы зафлоатили сайдбар, и он вывалился из контейнера и залез на футер. Исправим это с помощью псевдораспорки.

Вам нужно будет добавить контейнеру колонок класс clearfix. А после этого добавить несколько свойств в CSS-правило для псевдораспорки.

Простейшая сетка, финал [19/32]

Поздравляем! Вы победили выпадание. Теперь завершим сетку.

В почти готовую сетку мы добавили немного текста, чтобы посмотреть как она будет себя вести с наполнением. Сейчас видно, что синий
 блок контента частично залезает под сайдбар. Чтобы избавиться от этого эффекта, можно задать блоку контента маргин слева.

После этого сетка будет завершена. Кстати, мы получили ещё один интересный результат. Мы не зафлоатили блок контента, поэтому он
тянется на всю ширину родительского контейнера. А фиксированный маргин слева предохраняет его от заползания под сайдбар.

Таким образом, у нас получилась сетка из двух колонок, одна из которых фиксированная, а вторая тянется.
Здесь важно следующее — сайдбар в HTML коде должен располагаться до блока контента, иначе такого эффекта не получится.

simplegrid
-----------------------------------------
Сетка посложнее, шаг 1

Теперь построим более сложную сетку. В конце у нас получится вот такой результат:

Да, мы повторяем раскладку главной страницы HTML Academy: двухколончатый хедер и контент в три колонки.

На этом шаге создадим сетку хедера. Пока что работаем без содержания.

Сетка посложнее, шаг 2

Обратите внимание на способ именования классов: колонки имеют класс layout-column.

Префикс layout обозначает «сетка» или «раскладка». Таким образом, мы даём понять, что классы с этим
префиксом предназначены для создания сетки. Обычно для таких классов задают только флоаты, размеры и внешние отступы.

Использование значимых префиксов для именования классов — хороший приём. Используйте его в своей вёрстке.

На втором шаге мы создадим колонки содержания.


Сетка посложнее, шаг 3

Теперь нам нужно задать отступы между колонками содержания. Сделать это просто — добавим им маргин справа.
Но есть небольшая проблема. По макету последняя колонка должна прижиматься к правому краю контейнера.
Поэтому нам нужно обнулить маргин справа у последней колонки в содержании, иначе она не будет влезать в контейнер и перенесётся
на следующую строку.
Чтобы выбрать последнюю колонку, вы можете использовать псевдокласс :last-child, с которым вы уже знакомились в курсе про селекторы.
Сетка посложнее, добавляем содержание.

mediumgrid
------------------------------------------
Сетка готова. Осталось протестировать её с настоящим содержанием.
Мы уже добавили контент в разметку и спрятали его. Вам нужно лишь снова отобразить его, а также убрать вспомогательные границы и
 фоны, чтобы увидеть готовый результат.
Обратите внимание еще на один подход построения сеток. Он заключается в том, что блокам разметки задаются только размеры и
внешние отступы. Внутренние же отступы добавляются дополнительным элементам, вложенным в ячейки сетки.
Такой подход упрощает расчет сеток. Как вы помните, блочная модель устроена таким образом, что общий размер элемента
складывается из ширины/высоты, маргинов и паддингов, а также ширины рамок. Поэтому, чтобы получить правильные размеры блоков сетки,
 всегда нужно помнить об этом. Если же блокам сетки задавать только ширину и внешние отступы, то слагаемых становится намного меньше,
  а шанс совершить ошибку уменьшается.

mediumgriddone
  -------------------------------------------
Последняя сетка, шаг 1

Поздравляем с созданием первой сложной сетки! Теперь давайте немного усложним её. Мы будем делать сетку,
 у которой фон хедера и футера растягивается на всю ширину окна браузера, вот так:

Сначала нам нужно изменить HTML-разметку. Мы избавимся от блока wrapper, который центрует всё содержание страницы.

Затем нужно будет добавить внутрь хедера, контента и футера дополнительный блок, который будет центровать их содержимое. Вот так:

<div class="header clearfix">
    <div class="layout-positioner">
        <!-- блоки колонок -->
    </div>
</div>

Последняя сетка, шаг 2

Блоки с классом layout-positioner добавлены в код. Это невидимые блоки-центровщики. Теперь хедер и футер могут
тянуться на всю ширину окна, а их содержимое будет отцентровано с помощью добавленных блоков.
Мы задали голубую рамку для центровщиков, чтобы было видно, как они себя ведут. Также мы добавили им псевдораспорки,
поэтому можно удалить класс clearfix из HTML кода.
И еще одна мелочь: класс wrapper уже нигде не используется, поэтому он удалён из CSS. Класс clearfix мы оставили в CSS,
т. к. это вспомогательный класс, который может пригодиться при вёрстке.
На этом шаге ваша задача — отцентровать центровщики.

hardgrid
------------------------------------------------
Последняя сетка завершена

Последний шаг этой серии заданий — тестирование получившейся сетки с содержанием.
Контент уже добавлен и скрыт. Снова отобразите его, а также уберите вспомогательные рамки и фоны.
Приём с дополнительными блоками, которые позиционируют содержание, чтобы родительские блоки могли тянуться на
 всю ширину окна, достаточно распространён. Дизайн с подобными сетками тоже встречается очень часто.

hardgriddone
---------------------------------------------












