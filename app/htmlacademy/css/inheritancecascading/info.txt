Иерархическое дерево

HTML-документ представляет собой иерархическое дерево. Это означает, что у каждого элемента (кроме корневого) есть только один родитель,
т.е. элемент, внутри которого он располагается. У корневого раздела родитель отсутствует. Рассмотрим простейшую страницу:

<html>
   <head></head>
   <body>
      <p>Текст документа</p>
      <p class="text">Выделенная <span>строка</span></p>
   </body>
</html>
Для этой страницы можно нарисовать такое иерархическое дерево:

Оно схематически отображает структуру вложенности элементов. В данном примере видно, что у элемента span родителем является p.text,
а у p.text родитель — body.

Иерархическая структура документа определяет основы концепции наследования.

inheritancetree
---------------------------------
Наследование
Наследование в CSS — механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам.

Стили, присвоенные некоторому элементу, наследуются всеми потомками (вложенными элементами), если они не переопределены явно.
 Например, размер шрифта и его цвет достаточно применить к body, чтобы все элементы внутри имели те же свойства.

Наследование позволяет сократить размер таблицы стилей, но если стилей много, то отследить какой родительский элемент установил
некоторое свойство, становится сложнее.

inheritance
--------------------------------
Наследование «на пальцах»

Давайте на простых примерах подробнее разберёмся, в чём же преимущество наследования.

Рассмотрим пример:

<p class="text">Cтрока c выделенным <span>словом</span></p>
Представим, что нам нужно установить красный цвет шрифта для всего текста. Зададим CSS-свойства следующим образом:

.text {
    color: red;
}
Благодаря наследованию цвет шрифта в теге span автоматически станет красным:

Cтрока c выделенным словом
А так бы выглядел результат, если бы наследование не работало:

Cтрока c выделенным словом
Нам пришлось бы отдельно прописывать цвет шрифта для тега span. И тогда установка таких простых свойств как стиль шрифта
стала бы большой проблемой: нужно было бы задавать свойства для всех возможных вложенных тегов.

fingerinheritance
--------------------------------------------------
Ещё немного про наследование

Наверняка вы обращали внимание, что не все свойства наследуются тегами-потомками от их родителей.
Действительно, было бы странно, если бы свойство border автоматически устанавливалось для всех вложенных элементов.
Например, для этого куска кода:

<p class="bordered">Cтрока c выделенным <span>словом</span></p>
Установим CSS-свойство:

.bordered {
    border: 1px solid green;
}
Если бы наследовались все свойства, то результат бы выглядел так:
Cтрока c выделенным словом
На самом деле граница будет нарисована только у тега p.
О том, какие именно свойства наследуются, мы расскажем в следующих заданиях.

inheritancemore
-------------------------------------------------
Наследуемые свойства
К наследуемым свойствам относятся в первую очередь свойства, определяющие параметры отображения текста:

font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing
, white-space, direction и т. д.

Также к наследуемым свойствам относятся list-style, cursor, visibility, border-collapse и некоторые другие. Но они используются значительно
 реже.

Весь список наследуемых свойств смотрите в стандарте CSS. Значение yes в колонке Inherited?.
Эти свойства можно и нужно задавать через предков, следуя семантике документа.

Например, параметры текста зачастую не меняются в пределах отдельных блоков страницы: меню, основного содержания, информационных панелей.
 Поэтому общие параметры текста (цвет, размер, гарнитура) обычно указывают в стилях самих блоков.

inheritedproperties
------------------------------------------------
Ненаследуемые свойства
В предыдущем задании мы перечислили основные наследуемые свойства. Все остальные относятся к ненаследуемым. Это параметры
позиционирования, размеров, отступов, фона, рамок и т. д.

А именно: background, border, padding, margin, width, height, position и др.

Весь список ненаследуемых свойств смотрите в стандарте CSS. Значение no в колонке Inherited?.
Не наследуются они из соображений здравого смысла. Например: если для какого-либо блока установлен внутренний отступ, автоматически
 выставлять такой же отступ каждому вложенному элементу нет никакой надобности. Эти параметры чаще всего уникальны для каждого отдельного
  блока.

noninherited
--------------------------------------------------
Принудительное наследование
ля каждого свойства может быть задано значение inherit.

Оно означает, что данное свойство принимает такое же значение, как и у родительского элемента. Значение inherit может быть
 использовано для усиления наследуемых значений, а также в свойствах, которые обычно не наследуются.
Запись выглядит следующим образом:

p {
    background: inherit;
}
В данном случае у тегов p свойство background будет таким же, как и у их родительских тегов.

forcedinheritance
---------------------------------------------------
Каскадирование

CSS расшифровывается как «Cascading Style Sheets» или «каскадные таблицы стилей».

Каскадность обозначает, что к одному и тому же элементу может применяться несколько CSS-правил (наборов CSS-свойств).
Среди этих свойств могут быть и конфликтующие между собой. Поэтому существуют инструкции, которые определяют, каким будет финальный
 набор свойств элемента.

Например, для элемента:

<p class="text" style="color: red;"></p>
CSS-правила существуют как минимум в трёх разных местах:

в подключаемом файле style.css для селекторов p или .text;
в атрибуте style;
в стандартных стилях отображения, встроенных в браузер.
Каскадирование как раз и определяет, какие именно свойства из этих источников применятся к данному абзацу.

Имеется три основные концепции, управляющие порядком, в котором применяются CSS-свойства:

важность;
специфичность;
порядок исходного кода.
Самыми важными для нас являются последние две и подробнее о них мы поговорим отдельно.

cascading
--------------------------------------------------
Битва за курочку
Перед тем как разбирать сложные правила работы каскадирования, расчёта специфичности и определения приоритетов, потренируемся на котиках.
Разберём пример. Вот HTML-код, в котором есть абзац с двумя классами:
<p class="red blue">Синий или красный?</p>
А вот CSS-код c двумя правилами для этих классов:

.blue {
    color: blue;
}

.red {
    color: red;
}
Вопрос: какого цвета будет текст абзаца? Какое из CSS-правил приоритетнее?

Ответ: красного цвета, второе правило приоритетнее.

Это происходит потому, что селекторы у правил одинакового типа, и соответственно обладают одинаковой специфичностью. В таком случае
более высоким приоритетом обладает то правило, которое расположено в CSS-коде ниже. В нашем случае это правило для класса red.

В этой серии заданий вам нельзя менять значения CSS-свойств, но можно изменять селекторы или менять порядок CSS-правил в коде.

chickenfightf
-------------------------------------------------
Битва за курочку. Раунд второй
Чуть более сложный пример. Тот же HTML:

<p class="red blue">Синий или красный?</p>
Немного другой CSS:

p.blue {
    color: blue;
}

.red {
    color: red;
}
В этом случае текст абзаца будет синим. Происходит это потому, что селектор p.blue более специфичный, чем селектор .red.

Простое объяснение специфичности звучит так:

Чем меньшее количество элементов потенциально может выбрать селектор, тем он специфичнее.
В нашем примере селектор .red выберет все теги с нужным классом, а селектор p.blue выберет только абзацы с нужным классом.

Заметьте, что в этом задании одно из CSS-правил вынесено в заблокированный HTML-код, а вам нужно победить его, усилив другое CSS-правило.

chickenfights
-----------------------------------------------
Битва за курочку. Раунд третий
v class="experiment">
    <p class="red blue">Синий или красный?</p>
</div>
И в CSS используем контекстный селектор для второго правила:

p.blue {
    color: blue;
}

.experiment .red {
    color: red;
}
Какой теперь будет цвет текста?

Кексик и Рудольф помогут разобраться, какой селектор специфичнее.

chickenfigtht
----------------------------------------------
















