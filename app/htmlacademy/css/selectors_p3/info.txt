Селекторы, часть 3 CSS
Рассмотрим продвинутые селекторы, умеющие искать элементы по подстрокам в атрибутах,
 а также огромное количество селекторов для стилизации элементов форм, таких как :required, :optional и :checked.
 ------------------------
Ищем в начале строки: [foo^="bar"]

В первом курсе про селекторы мы разбирали селектор по атрибутам, когда запись input[type="text"] выберет все элементы input,
у которых атрибут type равен text.

У этого механизма есть дополнительные возможности: можно выбирать элементы по вхождению подстроки в значение атрибута.

Запись вида [foo^="bar"] выберет все элементы, у которых значение атрибута foo начинается с подстроки bar.

Представьте, что у вас есть три класса для задания колонок разной ширины, например: column-1, column-2 и column-3.

У этих классов часть свойств повторяется, а разной является только ширина. Чтобы не дублировать CSS-код, вы можете вынести общие
 свойства колонок в правило с селектором [class^="column-"], а в остальных правилах задать только ширину:

[class^="column-"] {
    /* общие свойства: отступы, рамки, фон и т.д. */
}
.column-1 { width: 100px; }
.column-2 { width: 200px; }
.column-3 { width: 300px; }
То есть, первый селектор выберет все дивы с классами, начинающимися на column-:

<div class="column-1"></div>
<div class="column-2"></div>
<div class="column-3"></div>
Обратите внимание, что селектор чувствителен к регистру.

Селекторы этого курса относятся к спецификации CSS3 и работают во всех распространённых современных браузерах.

searchline
----------------------------------------
Ищем в конце строки: [foo$="bar"]

Селектор вида [foo$="bar"] выбирает все элементы, значение атрибута foo которых оканчивается строкой bar.

Представьте, что у вас на сайте есть раздел с файлами для скачивания в разных форматах и вам нужно для
каждого типа файлов добавить свою иконку. Пример разметки:

<a href="batman.pdf">Скачать</a>
<a href="superman.doc">Скачать</a>
В этом случае вы можете назначать иконки в CSS по расширениям файлов:

a[href$=".pdf"] {
    /* иконка для PDF */
}
a[href$=".doc"] {
    /* иконка для DOC */
}
И снова, селектор чувствителен к регистру.

searchlineend
----------------------------------------
Поиск подстроки везде: [foo*="bar"] [3/18]

Следующий вариант записи [foo*="bar"]

Будут выбраны все элементы, у которых значение атрибута foo содержит подстроку bar на любой позиции

Среди трёх элементов:

<p class="person-name"></p>
<div class="some-person-info"></p>
<span class="date-person"></span>
селектор [class*="person"] выберет все.

Обратите внимание, что селектор чувствителен к регистру.

searcheverywhere
----------------------------------------
Поиск слов внутри строки: [foo~="bar"] [4/18]

Следующая запись: [foo~="bar"].

Такой селектор выберет все элементы, у которых значение атрибута foo содержит слово bar.

Входить должно именно слово, а не просто подстрока. То есть вхождение bar должно содержать с обеих сторон разделители:
пробелы или начало/конец строки.

searchinsideline
----------------------------------------
Поиск префиксов: [foo|="bar"] [5/18]

Селектор по атрибутам вида [foo|="bar"]

В данном случае будут выбраны все элементы, у которых значение атрибута foo содержит префикс bar, то
 есть либо полностью совпадает с bar, либо начинается со строки bar- (наличие знака переноса существенно). Другими словами,
  используя уже знакомые записи селекторов, этот можно заменить на два:
1. [foo="bar"] — все элементы, у которых значение атрибута foo полностью совпадает со значением bar.
2. [foo^="bar-"] — все элементы, у которых значение атрибута foo начинается со значения bar-.

searchprefixline
-----------------------------------------
Поиски котов. Часть 1

Наверно все уже устали от этих форм, поэтому немного сменим тему и займемся поисками котов.
Естественно, используя уже изученные новые селекторы.
В этот раз история совсем простая: из продуктового магазина выкинули старые коробки, и все коты с округи сбежались и залезли в них.
 Будем искать, кто в какой!
Ищем котов по значению атрибута title у элемента .cat-in-box.
Чтобы открыть коробку, необходимо у элемента .cat-in-box взять псевдоэлемент before и установить ему свойство display:
 none;, а чтобы закрыть — display: block;.
Объединяйте селекторы, чтобы найти нужную коробку.


findcatsf
-----------------------------------------
Поиски котов. Часть 2

Поиски котов продолжаются!
Ищем котов по значению атрибута title у элемента .cat-in-box
Чтобы открыть коробку необходимо у элемента .cat-in-box взять псевдоэлемент before и установить ему свойство display: none,
а чтобы закрыть - display: block
Объединяйте селекторы, чтобы найти нужную коробку

findcatsse
-----------------------------------------
Котография 9 на 12
Кексик напечатал целую пачку фотографий всех своих знакомых, да еще в разных форматах.

Но, как обычно, все пошло не так, как он рассчитывал: рамочек оказалось мало, да и часть фотографий испорчена.
И Кексику, естественно, нужна ваша помощь.

cotography
-----------------------------------------
Псевдоклассы :enabled и :disabled

В предыдущих курсах мы уже научились работать с формами и разными полями форм. Теперь рассмотрим ряд дополнительных
селекторов для работы с этими элементами.

Для обращения к элементам, которые являются доступными на сайте (не заблокированными), можно использовать псевдокласс
:enabled. Заблокированными считаются элементы форм, у которых установлен атрибут disabled. Подробнее об этом атрибуте
 можно посмотреть в этом курсе

Например:

input:enabled {
   /* какие-то стили */
}
И наоборот, если нужно обратиться только к заблокированным элементам, то для этого есть псевдокласс :disabled


enableddisabled
------------------------------------------
Псевдоклассы :read-only и :read-write

Как мы уже рассматривали в предыдущих курсах, есть разные способы запретить редактирование пользователем полей.
Одним из таковых является установка атрибута readonly. Значение в данном случае доступно для чтения и копирования, но недоступно
 для редактирования.

В зависимости от этого параметра существует два селектора, которые позволяют выбирать каждую группу полей

Селектор :read-write выберет все поля доступные для редактирования

Селектор :read-only выберет все поля доступные только для чтения

Пример записи

input:read-only {}
К сожалению, пока еще не все браузеры поддерживают данные селекторы. Но их можно заменить на другие селекторы,
которые делают то же самое:

input[readonly] {} /* аналог :read-only */
input:not([readonly]) {} /* аналог :read-write */

readonlyreadwrite
------------------------------------------
Псевдокласс :required

Мы уже разбирали, что при помощи специального атрибута required можно отметить поля, обязательные для заполнения.
Используя селектор :required можно задать отдельные стили для этих полей.

Например

input:required {}

required
-------------------------------------------
Псевдокласс :optional

Помимо :required существует селектор :optional, выполняющий обратное действие. То есть выберутся все элементы, у которых
НЕ указан атрибут required
Пример записи
select:optional {}

optional
--------------------------------------------
Псевдокласс :checked

При помощи селектора :checked можно обратиться ко всем элементам input с типами checkbox или radio,
которые являются выбранными (отмеченными)
Например

input:checked {}

checked
--------------------------------------------
Псевдоклассы :invalid и :valid [14/18]

При помощи разных типов полей (email, url и др.) или специфических настроек (pattern, min/max и др.) можно указать браузеру,
какие именно данные мы ожидаем от пользователя в том или ином поле.

Селектор :valid выберет все элементы, у которых введенное значение удовлетворяет требованиям.

А селектор :invalid соответственно выберет элементы, у которых введенное значение некорректно.

Пример записи:

input:invalid { }

validinvalid
--------------------------------------------
